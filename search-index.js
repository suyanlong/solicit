var searchIndex = {};
searchIndex["solicit"] = {"doc":"","items":[[0,"http","solicit","The module implements the framing layer of HTTP/2 and exposes an API for using it.",null,null],[3,"HeaderPart","solicit::http","A convenience struct representing a part of a header (either the name or the value) that can be either an owned or a borrowed byte sequence.",null,null],[3,"Header","","Represents an HTTP/2 header. Allows both the name and the value to be either an owned or a borrowed byte sequence.",null,null],[3,"ConnectionError","","The struct represents a connection error arising on an HTTP/2 connection.",null,null],[3,"WindowSize","","The struct represents the size of a flow control window.",null,null],[3,"Response","","A struct representing the full raw response received on an HTTP/2 connection.",null,null],[12,"stream_id","","The ID of the stream to which the response is associated. HTTP/1.1 does not really have an equivalent to this.",0,null],[12,"headers","","Exposes all the raw response headers, including the meta-headers. (For now the only meta header allowed in HTTP/2 responses is the `:status`.)",0,null],[12,"body","","The full body of the response as an uninterpreted sequence of bytes.",0,null],[3,"Request","","A struct representing a full HTTP/2 request, along with the full body, as a sequence of bytes.",null,null],[12,"stream_id","","",1,null],[12,"headers","","",1,null],[12,"body","","",1,null],[4,"ErrorCode","","The enum represents an error code that are used in `RST_STREAM` and `GOAWAY` frames. These are defined in Section 7 of the HTTP/2 spec.",null,null],[13,"NoError","","The associated condition is not a result of an error. For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.",2,null],[13,"ProtocolError","","The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.",2,null],[13,"InternalError","","The endpoint encountered an unexpected internal error.",2,null],[13,"FlowControlError","","The endpoint detected that its peer violated the flow-control protocol.",2,null],[13,"SettingsTimeout","","The endpoint sent a SETTINGS frame but did not receive a response in a timely manner. See Section 6.5.3 (\"Settings Synchronization\").",2,null],[13,"StreamClosed","","The endpoint received a frame after a stream was half-closed.",2,null],[13,"FrameSizeError","","The endpoint received a frame with an invalid size.",2,null],[13,"RefusedStream","","The endpoint refused the stream prior to performing any application processing (see Section 8.1.4 for details).",2,null],[13,"Cancel","","Used by the endpoint to indicate that the stream is no longer needed.",2,null],[13,"CompressionError","","The endpoint is unable to maintain the header compression context for the connection.",2,null],[13,"ConnectError","","The connection established in response to a CONNECT request (Section 8.3) was reset or abnormally closed.",2,null],[13,"EnhanceYourCalm","","The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.",2,null],[13,"InadequateSecurity","","The underlying transport has properties that do not meet minimum security requirements (see Section 9.2).",2,null],[13,"Http11Required","","The endpoint requires that HTTP/1.1 be used instead of HTTP/2.",2,null],[4,"HttpError","","An enum representing errors that can arise when performing operations involving an HTTP/2 connection.",null,null],[13,"IoError","","The underlying IO layer raised an error",3,null],[13,"InvalidFrame","","The HTTP/2 connection received an invalid HTTP/2 frame",3,null],[13,"PeerConnectionError","","The peer indicated a connection error",3,null],[13,"CompressionError","","The HPACK decoder was unable to decode a header chunk and raised an error. Any decoder error is fatal to the HTTP/2 connection as it means that the decoder contexts will be out of sync.",3,null],[13,"WindowSizeOverflow","","Indicates that the local peer has discovered an overflow in the size of one of the connection flow control window, which is a connection error.",3,null],[13,"UnknownStreamId","","",3,null],[13,"UnableToConnect","","",3,null],[13,"MalformedResponse","","",3,null],[13,"Other","","",3,null],[4,"HttpScheme","","An enum representing the two possible HTTP schemes.",null,null],[13,"Http","","The variant corresponding to `http://`",4,null],[13,"Https","","The variant corresponding to `https://`",4,null],[0,"frame","","The module contains the implementation of HTTP/2 frames.",null,null],[3,"NoFlag","solicit::http::frame","A helper struct that can be used by all frames that do not define any flags.",null,null],[3,"RawFrame","","A struct that defines the format of the raw HTTP/2 frame, i.e. the frame as it is read from the wire.",null,null],[5,"unpack_header","","Deconstructs a `FrameHeader` into its corresponding 4 components, represented as a 4-tuple: `(length, frame_type, flags, stream_id)`.",null,{"inputs":[{"name":"frameheaderbuffer"}],"output":{"name":"frameheader"}}],[5,"pack_header","","Constructs a buffer of 9 bytes that represents the given `FrameHeader`.",null,{"inputs":[{"name":"frameheader"}],"output":{"name":"frameheaderbuffer"}}],[0,"builder","","Defines the `FrameBuilder` trait and some default implementations of the trait.",null,null],[8,"FrameBuilder","solicit::http::frame::builder","A trait that provides additional methods for serializing HTTP/2 frames.",null,null],[11,"write_header","","Write the given frame header as the next octets (i.e. without moving the cursor to the beginning of the buffer).",5,{"inputs":[{"name":"self"},{"name":"frameheader"}],"output":{"name":"result"}}],[11,"overwrite_header","","Overwrite the previously written header, assuming it's the first byte sequence of the buffer.",5,{"inputs":[{"name":"self"},{"name":"frameheader"}],"output":{"name":"result"}}],[11,"copy_bytes_from","","Copy all available bytes from the given `io::Read` instance.",5,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"result"}}],[11,"write_padding","","Write the given number of padding octets.",5,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_u32","","Write the given unsigned 32 bit integer to the underlying stream. The integer is written as four bytes in network endian style.",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[0,"data","solicit::http::frame","The module contains the implementation of the `DATA` frame and associated flags.",null,null],[3,"DataChunk","solicit::http::frame::data","A helper struct that allows the chunk to be either borrowed or owned. Used to provide the `From` implementations that allow us to implement generic methods that accept any type that can be converted into a `DataChunk` (given that the native `Cow` type does not have these implementations and we cannot add them).",null,null],[3,"DataFrame","","A struct representing the DATA frames of HTTP/2, as defined in the HTTP/2 spec, section 6.1.",null,null],[12,"data","","The data found in the frame as an opaque byte sequence. It never includes padding bytes.",6,null],[4,"DataFlag","","An enum representing the flags that a `DataFrame` can have. The integer representation associated to each variant is that flag's bitmask.",null,null],[13,"EndStream","","",7,null],[13,"Padded","","",7,null],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"dataflag"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",7,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"from","","",8,{"inputs":[{"name":"vec"}],"output":{"name":"datachunk"}}],[11,"from","","",8,null],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"dataframe"}}],[11,"new","","Creates a new empty `DataFrame`, associated to the stream with the given ID.",6,{"inputs":[{"name":"streamid"}],"output":{"name":"dataframe"}}],[11,"with_data","","Creates a new `DataFrame` with the given `DataChunk`.",6,{"inputs":[{"name":"streamid"},{"name":"d"}],"output":{"name":"dataframe"}}],[11,"is_padded","","Returns `true` if the DATA frame is padded, otherwise false.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the number of bytes that should be used as padding for this frame.",6,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"payload_len","","Returns the total length of the payload, taking into account possible padding.",6,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_flag","","Sets the given flag for the frame.",6,{"inputs":[{"name":"self"},{"name":"dataflag"}],"output":null}],[11,"from_raw","","Creates a new `DataFrame` from the given `RawFrame` (i.e. header and payload), if possible.  Returns `None` if a valid `DataFrame` cannot be constructed from the given `RawFrame`.",6,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",6,{"inputs":[{"name":"self"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",6,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the frame.",6,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",6,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"headers","solicit::http::frame","The module contains the implementation of the `HEADERS` frame and associated flags.",null,null],[3,"StreamDependency","solicit::http::frame::headers","The struct represents the dependency information that can be attached to a stream and sent within a HEADERS frame (one with the Priority flag set).",null,null],[12,"stream_id","","The ID of the stream that a particular stream depends on",9,null],[12,"weight","","The weight for the stream. The value exposed (and set) here is always in the range [0, 255], instead of [1, 256] (as defined in section 5.3.2.) so that the value fits into a `u8`.",9,null],[12,"is_exclusive","","A flag indicating whether the stream dependency is exclusive.",9,null],[3,"HeadersFrame","","A struct representing the HEADERS frames of HTTP/2, as defined in the HTTP/2 spec, section 6.2.",null,null],[12,"stream_id","","The ID of the stream with which this frame is associated",10,null],[12,"stream_dep","","The stream dependency information, if any.",10,null],[12,"padding_len","","The length of the padding, if any.",10,null],[4,"HeadersFlag","","An enum representing the flags that a `HeadersFrame` can have. The integer representation associated to each variant is that flag's bitmask.",null,null],[13,"EndStream","","",11,null],[13,"EndHeaders","","",11,null],[13,"Padded","","",11,null],[13,"Priority","","",11,null],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"headersflag"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",11,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"streamdependency"}}],[11,"new","","Creates a new `StreamDependency` with the given stream ID, weight, and exclusivity.",9,{"inputs":[{"name":"streamid"},{"name":"u8"},{"name":"bool"}],"output":{"name":"streamdependency"}}],[11,"parse","","Parses the first 5 bytes in the buffer as a `StreamDependency`. (Each 5-byte sequence is always decodable into a stream dependency structure).",9,null],[11,"serialize","","Serializes the `StreamDependency` into a 5-byte buffer representing the dependency description, as described in section 6.2. of the HTTP/2 spec:",9,null],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"headersframe"}}],[11,"new","","Creates a new `HeadersFrame` with the given header fragment and stream ID. No padding, no stream dependency, and no flags are set.",10,{"inputs":[{"name":"vec"},{"name":"streamid"}],"output":{"name":"headersframe"}}],[11,"with_dependency","","Creates a new `HeadersFrame` with the given header fragment, stream ID and stream dependency information. No padding and no flags are set.",10,{"inputs":[{"name":"vec"},{"name":"streamid"},{"name":"streamdependency"}],"output":{"name":"headersframe"}}],[11,"is_headers_end","","Returns whether this frame ends the headers. If not, there MUST be a number of follow up CONTINUATION frames that send the rest of the header data.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the padding length for the frame, as well as the corresponding Padded flag.",10,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"header_fragment","","",10,null],[11,"set_flag","","Sets the given flag for the frame.",10,{"inputs":[{"name":"self"},{"name":"headersflag"}],"output":null}],[11,"from_raw","","Creates a new `HeadersFrame` with the given `RawFrame` (i.e. header and payload), if possible.",10,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",10,{"inputs":[{"name":"self"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",10,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",10,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",10,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"rst_stream","solicit::http::frame","The module contains the implementation of the `RST_STREAM` frame.",null,null],[3,"RstStreamFrame","solicit::http::frame::rst_stream","The struct represents the `RST_STREAM` HTTP/2 frame.",null,null],[17,"RST_STREAM_FRAME_LEN","","The total allowed size for the `RST_STREAM` frame payload.",null,null],[17,"RST_STREAM_FRAME_TYPE","","The frame type of the `RST_STREAM` frame.",null,null],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"rststreamframe"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"rststreamframe"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"rststreamframe"}],"output":{"name":"bool"}}],[11,"new","","Constructs a new `RstStreamFrame` with the given `ErrorCode`.",12,{"inputs":[{"name":"streamid"},{"name":"errorcode"}],"output":{"name":"rststreamframe"}}],[11,"with_raw_error_code","","Constructs a new `RstStreamFrame` that will use the given `raw_error_code` for its payload.",12,{"inputs":[{"name":"streamid"},{"name":"u32"}],"output":{"name":"rststreamframe"}}],[11,"error_code","","Returns the interpreted error code of the frame. Any unknown error codes are mapped into the `InternalError` variant of the enum.",12,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"raw_error_code","","Returns the original raw error code of the frame. If the code is unknown, it will not be changed.",12,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_raw","","",12,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",12,{"inputs":[{"name":"self"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",12,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","",12,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",12,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"settings","solicit::http::frame","The module contains the implementation of the `SETTINGS` frame and associated flags.",null,null],[3,"SettingsFrame","solicit::http::frame::settings","A struct representing the SETTINGS frames of HTTP/2, as defined in the HTTP/2 spec, section 6.5.",null,null],[12,"settings","","Contains all the settings that are currently set in the frame. It is safe to access this field (to read, add, or remove settings), even though a helper method `add_setting` exists.",13,null],[4,"HttpSetting","","An enum that lists all valid settings that can be sent in a SETTINGS frame.",null,null],[13,"HeaderTableSize","","",14,null],[13,"EnablePush","","",14,null],[13,"MaxConcurrentStreams","","",14,null],[13,"InitialWindowSize","","",14,null],[13,"MaxFrameSize","","",14,null],[13,"MaxHeaderListSize","","",14,null],[4,"SettingsFlag","","An enum representing the flags that a `SettingsFrame` can have. The integer representation associated to each variant is that flag's bitmask.",null,null],[13,"Ack","","",15,null],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"httpsetting"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_id","","Creates a new `HttpSetting` with the correct variant corresponding to the given setting id, based on the settings IDs defined in section 6.5.2.",14,{"inputs":[{"name":"u16"},{"name":"u32"}],"output":{"name":"option"}}],[11,"get_id","","Returns the setting ID as an unsigned 16 bit integer, as defined in section 6.5.2.",14,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"get_val","","Gets the setting value by unpacking it from the wrapped `u32`.",14,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"settingsflag"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"settingsframe"}}],[11,"new","","Creates a new `SettingsFrame`",13,{"inputs":[],"output":{"name":"settingsframe"}}],[11,"new_ack","","A convenience constructor that returns a `SettingsFrame` with the ACK flag already set and no settings.",13,{"inputs":[],"output":{"name":"settingsframe"}}],[11,"add_setting","","Adds the given setting to the frame.",13,{"inputs":[{"name":"self"},{"name":"httpsetting"}],"output":null}],[11,"set_ack","","Sets the ACK flag for the frame. This method is just a convenience method for calling `frame.set_flag(SettingsFlag::Ack)`.",13,{"inputs":[{"name":"self"}],"output":null}],[11,"is_ack","","Checks whether the `SettingsFrame` has an ACK attached to it.",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_flag","","Sets the given flag for the frame.",13,{"inputs":[{"name":"self"},{"name":"settingsflag"}],"output":null}],[11,"from_raw","","Creates a new `SettingsFrame` with the given `RawFrame` (i.e. header and payload), if possible.",13,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",13,{"inputs":[{"name":"self"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",13,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",13,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",13,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"goaway","solicit::http::frame","Implements the `GOAWAY` HTTP/2 frame.",null,null],[3,"GoawayFrame","solicit::http::frame::goaway","The struct represents the `GOAWAY` HTTP/2 frame.",null,null],[17,"GOAWAY_MIN_FRAME_LEN","","The minimum size for the `GOAWAY` frame payload. It is 8 octets, as the last stream id and error code are required parts of the GOAWAY frame.",null,null],[17,"GOAWAY_FRAME_TYPE","","The frame type of the `GOAWAY` frame.",null,null],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"goawayframe"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"goawayframe"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"goawayframe"}],"output":{"name":"bool"}}],[11,"new","","Create a new `GOAWAY` frame with the given error code and no debug data.",16,{"inputs":[{"name":"streamid"},{"name":"errorcode"}],"output":{"name":"self"}}],[11,"with_debug_data","","Create a new `GOAWAY` frame with the given parts.",16,null],[11,"error_code","","Returns the interpreted error code of the frame. Any unknown error codes are mapped into the `InternalError` variant of the enum.",16,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"raw_error_code","","Returns the original raw error code of the frame. If the code is unknown, it will not be changed.",16,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"last_stream_id","","Returns the associated last stream ID.",16,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"debug_data","","Returns the debug data associated with the frame.",16,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"payload_len","","Returns the total length of the frame's payload, including any debug data.",16,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_raw","","",16,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",16,{"inputs":[{"name":"self"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",16,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","",16,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",16,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"ping","solicit::http::frame","Implements the `PING` HTTP/2 frame.",null,null],[3,"PingFlag","solicit::http::frame::ping","",null,null],[3,"PingFrame","","The struct represents the `PINg` HTTP/2 frame.",null,null],[17,"PING_FRAME_LEN","","Ping frames are always 8 bytes",null,null],[17,"PING_FRAME_TYPE","","The frame type of the `PING` frame.",null,null],[11,"bitmask","","",17,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"pingframe"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"pingframe"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"self"},{"name":"pingframe"}],"output":{"name":"bool"}}],[11,"new","","Create a new `PING` frame",18,{"inputs":[],"output":{"name":"self"}}],[11,"new_ack","","Create a new PING frame with ACK set",18,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"with_data","","Create a new `PING` frame with the given opaque_data",18,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"is_ack","","",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"opaque_data","","",18,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"from_raw","","",18,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",18,{"inputs":[{"name":"self"},{"name":"pingflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",18,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","",18,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",18,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"window_update","solicit::http::frame","Implements the `WINDOW_UPDATE` HTTP/2 frame.",null,null],[3,"WindowUpdateFrame","solicit::http::frame::window_update","The struct represents the `WINDOW_UPDATE` HTTP/2 frame.",null,null],[17,"WINDOW_UPDATE_FRAME_LEN","","The minimum size for the `WINDOW_UPDATE` frame payload.",null,null],[17,"WINDOW_UPDATE_FRAME_TYPE","","The frame type of the `WINDOW_UPDATE` frame.",null,null],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"windowupdateframe"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"windowupdateframe"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"windowupdateframe"}],"output":{"name":"bool"}}],[11,"for_connection","","Creates a new `WindowUpdateFrame` that will increment the connection-level window by the given increment.",19,{"inputs":[{"name":"u32"}],"output":{"name":"windowupdateframe"}}],[11,"for_stream","","Creates a new `WindowUpdateFrame` that will increment the given stream's window by the given increment.",19,{"inputs":[{"name":"streamid"},{"name":"u32"}],"output":{"name":"windowupdateframe"}}],[11,"increment","","Returns the window increment indicated by the frame.",19,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_raw","","",19,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","",19,{"inputs":[{"name":"self"},{"name":"noflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","",19,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[11,"get_header","","",19,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"serialize_into","","",19,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[6,"FrameHeaderBuffer","solicit::http::frame","An alias for the 9-byte buffer that each HTTP/2 frame header must be stored in.",null,null],[6,"FrameHeader","","An alias for the 4-tuple representing the components of each HTTP/2 frame header.",null,null],[17,"FRAME_HEADER_LEN","","",null,null],[8,"FrameIR","","A trait that types that are an intermediate representation of HTTP/2 frames should implement. It allows us to generically serialize any intermediate representation into an on-the-wire representation.",null,null],[10,"serialize_into","","Write out the on-the-wire representation of the frame into the given `FrameBuilder`.",20,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[8,"Flag","","A trait that all HTTP/2 frame header flags need to implement.",null,null],[10,"bitmask","","Returns a bit mask that represents the flag.",21,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[8,"Frame","","A trait that all HTTP/2 frame structs need to implement.",null,null],[16,"FlagType","","The type that represents the flags that the particular `Frame` can take. This makes sure that only valid `Flag`s are used with each `Frame`.",22,null],[10,"from_raw","","Creates a new `Frame` from the given `RawFrame` (i.e. header and payload), if possible.",22,{"inputs":[{"name":"rawframe"}],"output":{"name":"option"}}],[10,"is_set","","Tests if the given flag is set for the frame.",22,null],[10,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated",22,{"inputs":[{"name":"self"}],"output":{"name":"streamid"}}],[10,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",22,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"bitmask","","",23,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"rawframe"}}],[11,"parse","","Parses a `RawFrame` from the bytes starting at the beginning of the given buffer.",24,null],[11,"len","","Returns the total length of the `RawFrame`, including both headers, as well as the entire payload.",24,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"serialize","","Returns a `Vec` of bytes representing the serialized (on-the-wire) representation of this raw frame.",24,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"header","","Returns a `FrameHeader` instance corresponding to the headers of the `RawFrame`.",24,{"inputs":[{"name":"self"}],"output":{"name":"frameheader"}}],[11,"payload","","Returns a slice representing the payload of the `RawFrame`.",24,null],[11,"into","","",24,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"as_ref","","",24,null],[11,"from","","",24,{"inputs":[{"name":"vec"}],"output":{"name":"rawframe"}}],[11,"from","","",24,null],[11,"serialize_into","","",24,{"inputs":[{"name":"self"},{"name":"b"}],"output":{"name":"result"}}],[0,"transport","solicit::http","The module contains implementations of the transport layer functionality that HTTP/2 requires. It exposes APIs that allow the HTTP/2 connection to use the transport layer without requiring it to know which exact implementation they are using (e.g. a clear-text TCP connection, a TLS protected connection, or even a mock implementation).",null,null],[3,"TransportReceiveFrame","solicit::http::transport","The struct is a an implementation of the `ReceiveFrame` trait that wraps an existing `TransportStream` and uses it to provide HTTP/2 frames, when asked for one, by reading from the stream. The implementation always allocates a new buffer on the heap for every incoming frame.",null,null],[8,"TransportStream","","A trait that any struct that wants to provide the transport layer for HTTP/2 needs to implement.",null,null],[11,"read_exact","","A convenience method that performs as many `read` calls on the underlying `Read` implementation as it takes to fill the given buffer.",25,null],[10,"try_split","","Attempts to split the `TransportStream` instance into a new independently owned handle to the same underlying stream.",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"close","","Attempts to shutdown both ends of the transport stream.",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"new","","Create a new `TransportReceiveFrame` that will use the given `TransportStream` for reading the frame.",26,{"inputs":[{"name":"ts"}],"output":{"name":"transportreceiveframe"}}],[11,"recv_frame","","",26,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[0,"connection","solicit::http","The module contains the implementation of an HTTP/2 connection.",null,null],[3,"HttpConnection","solicit::http::connection","The struct implements the HTTP/2 connection level logic.",null,null],[12,"scheme","","The scheme of the connection",27,null],[3,"DataChunk","","The struct represents a chunk of data that should be sent to the peer on a particular stream.",null,null],[12,"data","","The data that should be sent.",28,null],[12,"stream_id","","The ID of the stream on which the data should be sent.",28,null],[12,"end_stream","","Whether the data chunk will also end the stream.",28,null],[3,"HttpConnectionSender","","The struct represents an `HttpConnection` that has been bound to a `SendFrame` reference, allowing it to send frames. It exposes convenience methods for various send operations that can be invoked on the underlying stream. The methods prepare the appropriate frames and queue their sending on the referenced `SendFrame` instance.",null,null],[4,"HttpFrame","","An enum representing all frame variants that can be returned by an `HttpConnection` can handle.",null,null],[13,"DataFrame","","",29,null],[13,"HeadersFrame","","",29,null],[13,"RstStreamFrame","","",29,null],[13,"SettingsFrame","","",29,null],[13,"PingFrame","","",29,null],[13,"GoawayFrame","","",29,null],[13,"WindowUpdateFrame","","",29,null],[13,"UnknownFrame","","",29,null],[4,"SendStatus","","The enum represents the success status of the operation of sending a next data chunk on an HTTP/2 connection.",null,null],[13,"Sent","","Indicates that a DATA frame was successfully sent",30,null],[13,"Nothing","","Indicates that nothing was sent, but that no errors occurred.",30,null],[4,"EndStream","","An enum indicating whether the `HttpConnection` send operation should end the stream.",null,null],[13,"Yes","","The stream should be closed",31,null],[13,"No","","The stream should still be kept open",31,null],[8,"SendFrame","","A trait that should be implemented by types that can provide the functionality of sending HTTP/2 frames.",null,null],[10,"send_frame","","Queue the given frame for immediate sending to the peer. It is the responsibility of each individual `SendFrame` implementation to correctly serialize the given `FrameIR` into an appropriate buffer and make sure that the frame is subsequently eventually pushed to the peer.",32,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"httpresult"}}],[8,"ReceiveFrame","","A trait that should be implemented by types that can provide the functionality of receiving HTTP/2 frames.",null,null],[10,"recv_frame","","Return a new `HttpFrame` instance. Unknown frames can be wrapped in the `HttpFrame::UnknownFrame` variant (i.e. their `RawFrame` representation).",33,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"self"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"httpframe"}}],[11,"from_raw","","",29,{"inputs":[{"name":"rawframe"}],"output":{"name":"httpresult"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"sendstatus"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"sendstatus"}],"output":{"name":"bool"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `DataChunk`.",28,{"inputs":[{"name":"cow"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"new_borrowed","","Creates a new `DataChunk` from a borrowed slice. This method should become obsolete if we can take an `Into<Cow<_, _>>` without using unstable features.",28,{"inputs":[{"name":"d"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"endstream"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"endstream"}],"output":{"name":"bool"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"rst_stream","","Send a RST_STREAM frame for the given frame id",34,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"errorcode"}],"output":{"name":"httpresult"}}],[11,"send_settings_ack","","Sends a SETTINGS acknowledge frame to the peer.",34,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[11,"send_ping_ack","","Sends a PING ack",34,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"httpresult"}}],[11,"send_ping","","Sends a PING request",34,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"httpresult"}}],[11,"send_headers","","A helper function that inserts the frames required to send the given headers onto the `SendFrame` stream.",34,{"inputs":[{"name":"self"},{"name":"h"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"httpresult"}}],[11,"send_data","","A helper function that inserts a frame representing the given data into the `SendFrame` stream. In doing so, the connection's outbound flow control window is adjusted appropriately.",34,{"inputs":[{"name":"self"},{"name":"datachunk"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Sends the chunk of data provided by the given `DataPrioritizer`.",34,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"httpresult"}}],[11,"new","","Creates a new `HttpConnection` that will use the given sender for writing frames.",27,{"inputs":[{"name":"httpscheme"}],"output":{"name":"httpconnection"}}],[11,"sender","","Creates a new `HttpConnectionSender` instance that will use the given `SendFrame` instance to send the frames that it prepares. This is a convenience struct so that clients do not have to pass the same `sender` reference to multiple send methods.",27,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"httpconnectionsender"}}],[11,"in_window_size","","Returns the current size of the inbound flow control window (i.e. the number of octets that the connection will accept and the peer will send at most, unless the window is updated).",27,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"out_window_size","","Returns the current size of the outbound flow control window (i.e. the number of octets that can be sent on the connection to the peer without violating flow control).",27,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"expect_settings","","The method processes the next frame provided by the given `ReceiveFrame` instance, expecting it to be a SETTINGS frame. Additionally, the frame cannot be an ACK settings frame, but rather it should contain the peer's settings.",27,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sess"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Handles the next frame incoming on the given `ReceiveFrame` instance.",27,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sess"}],"output":{"name":"httpresult"}}],[0,"session","solicit::http","Defines the interface for the session-level management of HTTP/2 communication. This is effectively an API that allows hooking into an HTTP/2 connection in order to handle events arising on the connection.",null,null],[3,"StreamIter","solicit::http::session","A newtype for an iterator over `Stream`s saved in a `SessionState`.",null,null],[3,"Client","","A phantom type for the `DefaultSessionState` struct that indicates that the struct should be geared for a client session.",null,null],[3,"Server","","A phantom type for the `DefaultSessionState` struct that indicates that the struct should be geared for a server session.",null,null],[3,"DefaultSessionState","","An implementation of the `SessionState` trait that tracks the active streams in a `HashMap`, mapping the stream ID to the concrete `Stream` instance.",null,null],[3,"DefaultStream","","An implementation of the `Stream` trait that saves all headers and data in memory.",null,null],[12,"stream_id","","The ID of the stream, if already assigned by the connection.",35,null],[12,"headers","","The headers associated with the stream (i.e. the response headers)",35,null],[12,"body","","The body of the stream (i.e. the response body)",35,null],[12,"state","","The current stream state.",35,null],[4,"StreamState","","The enum represents all the states that an HTTP/2 stream can be found in.",null,null],[13,"Idle","","",36,null],[13,"ReservedLocal","","",36,null],[13,"ReservedRemote","","",36,null],[13,"Open","","",36,null],[13,"HalfClosedRemote","","",36,null],[13,"HalfClosedLocal","","",36,null],[13,"Closed","","",36,null],[4,"StreamDataError","","The enum represents errors that can be returned from the `Stream::get_data_chunk` method.",null,null],[13,"Closed","","Indicates that the stream cannot provide any data, since it is closed for further writes from the peer's side.",37,null],[13,"Other","","A different error while trying to obtain the data chunk. Wraps a boxed `Error` impl.",37,null],[4,"StreamDataChunk","","The enum represents the successful completion of the `Stream::get_data_chunk` method.",null,null],[13,"Chunk","","A data chunk of the given size, after which more chunks can follow.",38,null],[13,"Last","","The chunk was the last one that the stream will ever write.",38,null],[13,"Unavailable","","No data currently available, but the stream isn't closed yet",38,null],[5,"default_client_state","","Create a new `DefaultSessionState` for a client session. This function is a workaround required due to rust-lang/rust#29023.",null,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[5,"default_server_state","","Create a new `DefaultSessionState` for a server session. This function is a workaround required due to rust-lang/rust#29023.",null,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[8,"Session","","A trait that defines the interface between an `HttpConnection` and the higher-levels that use it. Essentially, it allows the `HttpConnection` to pass information onto those higher levels through a well-defined interface.",null,null],[10,"new_data_chunk","","Notifies the `Session` that a new data chunk has arrived on the connection for a particular stream. Only the raw data is passed to the callback (all padding is already discarded by the connection).",39,null],[10,"new_headers","","Notifies the `Session` that headers have arrived for a particular stream. The given list of headers is already decoded by the connection. TODO: The Session should be notified separately for every header that is decoded.",39,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"end_of_stream","","Notifies the `Session` that a particular stream got closed by the peer.",39,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"rst_stream","","Notifies the `Session` that a particular stream was reset by the peer and provides the reason behind it.",39,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"new_settings","","Notifies the `Session` that the peer has sent a new set of settings. The session itself is responsible for acknowledging the receipt of the settings.",39,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"on_ping","","Notifies the `Session` that a PING request has been received. The session itself is responsible for replying with an ACK.",39,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[10,"on_pong","","Notifies the `Session` that a PING acknowledgement has been received.",39,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_goaway","","Notifies the `Session` that the peer has sent a GOAWAY frame, indicating that the connection is terminated.",39,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"errorcode"},{"name":"option"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[8,"SessionState","","A trait defining a set of methods for accessing and influencing an HTTP/2 session's state.",null,null],[16,"Stream","","The type of the `Stream` that the `SessionState` manages.",40,null],[10,"insert_outgoing","","Inserts the given `Stream` into the session's state, starting to track it. The `SessionState` should assign it the next available outgoing stream ID.",40,null],[10,"insert_incoming","","Inserts the given `Stream` into the session's state, considering it an incoming stream. TODO(mlalic): Allow the exact error to propagate out.",40,null],[10,"get_stream_ref","","Returns a reference to a `Stream` with the given `StreamId`, if it is found in the current session.",40,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"get_stream_mut","","Returns a mutable reference to a `Stream` with the given `StreamId`, if it is found in the current session.",40,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"remove_stream","","Removes the stream with the given `StreamId` from the session. If the stream was found in the session, it is returned in the result.",40,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"iter","","Returns an iterator over the streams currently found in the session.",40,{"inputs":[{"name":"self"}],"output":{"name":"streamiter"}}],[10,"len","","The number of streams tracked by this state object",40,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_closed","","Returns all streams that are closed and tracked by the session state.",40,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"Stream","","A trait representing a single HTTP/2 stream. An HTTP/2 connection multiplexes a number of streams.",null,null],[10,"new_data_chunk","","Handle a new data chunk that has arrived for the stream.",41,null],[10,"set_headers","","Set headers for a stream. A stream is only allowed to have one set of headers.",41,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[10,"set_state","","Sets the stream state to the newly provided state.",41,{"inputs":[{"name":"self"},{"name":"streamstate"}],"output":null}],[11,"on_rst_stream","","Invoked when the session detects that the peer has reset the stream (i.e. sent a RST_STREAM frame for this stream).",41,{"inputs":[{"name":"self"},{"name":"errorcode"}],"output":null}],[10,"get_data_chunk","","Places the next data chunk that should be written onto the stream into the given buffer.",41,null],[10,"state","","Returns the current state of the stream.",41,{"inputs":[{"name":"self"}],"output":{"name":"streamstate"}}],[11,"close","","Transitions the stream state to closed. After this, the stream is considered to be closed for any further reads or writes.",41,{"inputs":[{"name":"self"}],"output":null}],[11,"close_local","","Updates the `Stream` status to indicate that it is closed locally.",41,{"inputs":[{"name":"self"}],"output":null}],[11,"close_remote","","Updates the `Stream` status to indicate that it is closed on the remote peer's side.",41,{"inputs":[{"name":"self"}],"output":null}],[11,"is_closed","","Returns whether the stream is closed.",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_closed_local","","Returns whether the stream is closed locally.",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_closed_remote","","Returns whether the remote peer has closed the stream. This includes a fully closed stream.",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"next","","",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Creates a new `DefaultSessionState` for a client session with no known streams.",43,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[11,"new","","Creates a new `DefaultSessionState` for a server session with no known streams.",43,{"inputs":[],"output":{"name":"defaultsessionstate"}}],[11,"insert_outgoing","","",43,null],[11,"insert_incoming","","",43,null],[11,"get_stream_ref","","",43,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"get_stream_mut","","",43,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"remove_stream","","",43,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"iter","","",43,{"inputs":[{"name":"self"}],"output":{"name":"streamiter"}}],[11,"len","","Number of currently active streams",43,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"streamstate"}}],[11,"eq","","",36,{"inputs":[{"name":"self"},{"name":"streamstate"}],"output":{"name":"bool"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",37,{"inputs":[{"name":"e"}],"output":{"name":"streamdataerror"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"streamdatachunk"}}],[11,"eq","","",38,{"inputs":[{"name":"self"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"self"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"defaultstream"}}],[11,"new","","Create a new `DefaultStream`, where the ID is not yet assigned.",35,{"inputs":[],"output":{"name":"defaultstream"}}],[11,"with_id","","Create a new `DefaultStream` with the given ID.",35,{"inputs":[{"name":"streamid"}],"output":{"name":"defaultstream"}}],[11,"set_full_data","","Sets the outgoing data of the stream to the given `Vec`.",35,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"new_data_chunk","","",35,null],[11,"set_headers","","",35,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"set_state","","",35,{"inputs":[{"name":"self"},{"name":"streamstate"}],"output":null}],[11,"state","","",35,{"inputs":[{"name":"self"}],"output":{"name":"streamstate"}}],[11,"get_data_chunk","","",35,null],[0,"priority","solicit::http","The module exposes an API for defining data prioritization strategies.",null,null],[3,"SimplePrioritizer","solicit::http::priority","An implementation of the `DataPrioritizer` trait that is based on finding the first stream from the given `SessionState` instance that can send data and returning this chunk.",null,null],[8,"DataPrioritizer","","A trait that types that want to provide data to an HTTP/2 connection need to implement.",null,null],[10,"get_next_chunk","","Returns the next `DataChunk` that should be sent on the HTTP/2 connection. `None` indicates that currently there was no data that could be sent at that point.",44,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[11,"new","","Creates a new `SimplePrioritizer` that will use the given state to find stream data that should be sent and use the given buffer to hold the data of the returned chunk.",45,null],[11,"get_next_chunk","","",45,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[0,"client","solicit::http","The module contains a number of reusable components for implementing the client side of an HTTP/2 connection.",null,null],[3,"ClientStream","solicit::http::client","A convenience wrapper type that represents an established client network transport stream. It wraps the stream itself, the scheme of the protocol to be used, and the remote host name.",null,null],[12,"0","","",46,null],[12,"1","","",46,null],[12,"2","","",46,null],[3,"CleartextConnector","","A struct that establishes a cleartext TCP connection that can be used by an HTTP/2 connection. Defaults to using port 80.",null,null],[12,"host","","The host to which the connection should be established",47,null],[12,"port","","The port on which the connection should be established",47,null],[3,"CleartextConnectError","","A newtype wrapping the `io::Error`, as it occurs when attempting to establish an HTTP/2 connection over cleartext TCP (with prior knowledge).",null,null],[3,"RequestStream","","A struct representing a request stream. It provides the headers that are to be sent when initiating the request, as well as a `Stream` instance that handles the received response and provides the request body.",null,null],[12,"headers","","The list of headers that will be sent with the request.",48,null],[12,"stream","","The underlying `Stream` instance, which will handle the response, as well as optionally provide the body of the request.",48,null],[3,"ClientConnection","","The struct extends the `HttpConnection` API with client-specific methods (such as `start_request`) and wires the `HttpConnection` to the client `Session` callbacks.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the connection streams.",49,null],[3,"ClientSession","","An implementation of the `Session` trait specific to handling client HTTP/2 connections.",null,null],[5,"write_preface","","Writes the client preface to the given `io::Write` instance.",null,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[0,"tls","","The module contains helpers for implementing TLS-based client connections.",null,null],[3,"TlsConnector","solicit::http::client::tls","A struct implementing the functionality of establishing a TLS-backed TCP stream that can be used by an HTTP/2 connection. Takes care to set all the TLS options to those allowed by the HTTP/2 spec, as well as of the protocol negotiation.",null,null],[12,"host","","",50,null],[4,"TlsConnectError","","An enum representing possible errors that can arise when trying to establish an HTTP/2 connection over TLS.",null,null],[13,"IoError","","The variant corresponds to the underlying raw TCP connection returning an error.",51,null],[13,"SslError","","The variant corresponds to the TLS negotiation returning an error.",51,null],[13,"Http2NotSupported","","The variant corresponds to the case when the TLS connection is established, but the application protocol that was negotiated didn't end up being HTTP/2. It wraps the established SSL stream in order to allow the client to decide what to do with it (and the application protocol that was chosen).",51,null],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",51,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",51,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",51,{"inputs":[{"name":"error"}],"output":{"name":"tlsconnecterror"}}],[11,"from","","",51,{"inputs":[{"name":"sslerror"}],"output":{"name":"tlsconnecterror"}}],[11,"new","","Creates a new `TlsConnector` that will create a new `SslContext` before trying to establish the TLS connection. The path to the CA file that the context will use needs to be provided.",50,{"inputs":[{"name":"str"},{"name":"p"}],"output":{"name":"tlsconnector"}}],[11,"with_context","","Creates a new `TlsConnector` that will use the provided context to create the `SslStream` that will back the HTTP/2 connection.",50,{"inputs":[{"name":"str"},{"name":"sslcontext"}],"output":{"name":"tlsconnector"}}],[11,"build_default_context","","Builds up a default `SslContext` instance wth TLS settings that the HTTP/2 spec mandates. The path to the CA file needs to be provided.",50,{"inputs":[{"name":"path"}],"output":{"name":"result"}}],[11,"connect","","",50,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[8,"HttpConnectError","solicit::http::client","A marker trait for errors raised by attempting to establish an HTTP/2 connection.",null,null],[8,"HttpConnect","","A trait that can be implemented by structs that want to provide the functionality of establishing network connections for use by HTTP/2 connections.",null,null],[16,"Stream","","The type of the underlying transport stream that the `HttpConnection`s produced by this `HttpConnect` implementation will be based on.",52,null],[16,"Err","","The type of the error that can be produced by trying to establish the connection (i.e. calling the `connect` method).",52,null],[10,"connect","","Establishes a network connection that can be used by HTTP/2 connections.",52,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from","solicit::http","",3,{"inputs":[{"name":"e"}],"output":{"name":"httperror"}}],[11,"new","solicit::http::client","Creates a new `CleartextConnector` that will attempt to establish a connection to the given host on port 80.",47,{"inputs":[{"name":"str"}],"output":{"name":"cleartextconnector"}}],[11,"with_port","","Creates a new `CleartextConnector` that will attempt to establish a connection to the given host on the given port.",47,{"inputs":[{"name":"str"},{"name":"u16"}],"output":{"name":"cleartextconnector"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",53,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",53,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",53,{"inputs":[{"name":"error"}],"output":{"name":"cleartextconnecterror"}}],[11,"connect","","Establishes a cleartext TCP connection based on the host and port. If it is not possible, returns an `HttpError`.",47,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"with_connection","","Creates a new `ClientConnection` that will use the given `HttpConnection` for all its underlying HTTP/2 communication.",49,{"inputs":[{"name":"httpconnection"},{"name":"state"}],"output":{"name":"clientconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",49,{"inputs":[{"name":"self"}],"output":{"name":"httpscheme"}}],[11,"expect_settings","","Handles the next frame provided by the given frame receiver and expects it to be a `SETTINGS` frame. If it is not, it returns an error.",49,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"start_request","","Starts a new request based on the given `RequestStream`.",49,{"inputs":[{"name":"self"},{"name":"requeststream"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"send_ping","","Send a PING",49,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next incoming frame provided by the given `ReceiveFrame` instance. Handling a frame may cause changes to the session state exposed by the `ClientConnection`.",49,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",49,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"new","","Returns a new `ClientSession` associated to the given state.",54,{"inputs":[{"name":"state"},{"name":"s"}],"output":{"name":"clientsession"}}],[11,"new_data_chunk","","",54,null],[11,"new_headers","","",54,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"end_of_stream","","",54,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"rst_stream","","",54,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"new_settings","","",54,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_ping","","",54,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_pong","","",54,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[0,"server","solicit::http","The module contains a number of reusable components for implementing the server side of an HTTP/2 connection.",null,null],[3,"ServerSession","solicit::http::server","An implementation of the `Session` trait for a server-side HTTP/2 connection.",null,null],[3,"ServerConnection","","The struct provides a more convenient API for server-related functionality of an HTTP/2 connection, such as sending a response back to the client.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the connection streams.",55,null],[8,"StreamFactory","","The `ServerSession` requires an instance of a type that implements this trait in order to create a new `Stream` instance once it detects that a client has initiated a new stream. The factory should take care to provide an appropriate `Stream` implementation that will be able to handle reading the request and generating the response, according to the needs of the underlying application.",null,null],[16,"Stream","","",56,null],[10,"create","","Create a new `Stream` with the given ID.",56,null],[11,"new","","",57,{"inputs":[{"name":"state"},{"name":"f"},{"name":"s"}],"output":{"name":"serversession"}}],[11,"new_data_chunk","","",57,null],[11,"new_headers","","",57,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"end_of_stream","","",57,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"rst_stream","","",57,{"inputs":[{"name":"self"},{"name":"streamid"},{"name":"errorcode"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"new_settings","","",57,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_ping","","",57,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"on_pong","","",57,{"inputs":[{"name":"self"},{"name":"pingframe"},{"name":"httpconnection"}],"output":{"name":"httpresult"}}],[11,"with_connection","","Creates a new `ServerConnection` that will use the given `HttpConnection` for its underlying HTTP/2 communication. The `state` and `factory` represent, respectively, the initial state of the connection and an instance of the `StreamFactory` type (allowing the client to handle newly created streams).",55,{"inputs":[{"name":"httpconnection"},{"name":"state"},{"name":"f"}],"output":{"name":"serverconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",55,{"inputs":[{"name":"self"}],"output":{"name":"httpscheme"}}],[11,"send_settings","","Send the current settings associated to the `ServerConnection` to the client.",55,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"expect_settings","","Handles the next frame on the given `ReceiveFrame` instance and expects it to be a (non-ACK) SETTINGS frame. Returns an error if not.",55,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next frame provided by the given `ReceiveFrame` instance. Handling the frame can cause the session state of the `ServerConnection` to update.",55,{"inputs":[{"name":"self"},{"name":"recv"},{"name":"sender"}],"output":{"name":"httpresult"}}],[11,"start_response","","Starts a response on the stream with the given ID by sending the given headers.",55,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"streamid"},{"name":"endstream"},{"name":"s"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",55,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"httpresult"}}],[6,"StreamId","solicit::http","An alias for the type that represents the ID of an HTTP/2 stream",null,null],[6,"OwnedHeader","","An alias for the type that represents an HTTP/2 header where both the name and the value is owned.",null,null],[6,"StaticHeader","","A type alias for a `Header` where both the name, as well as the value must have a `'static` lifetime if it is borrowed. Owned parts are allowed.",null,null],[6,"HttpResult","","A convenience `Result` type that has the `HttpError` type as the error type and a generic Ok result type.",null,null],[6,"StaticResponse","","A type alias for a `Response` where all headers' names and values must have a `'static` lifetime if they are borrowed. This means that the parts can also be owned.",null,null],[17,"INITIAL_CONNECTION_WINDOW_SIZE","","The initial size of the connections' flow control window.",null,null],[17,"ALPN_PROTOCOLS","","A set of protocol names that the library should use to indicate that HTTP/2 is supported during protocol negotiation (NPN or ALPN). We include some of the drafts' protocol names, since there is basically no difference for all intents and purposes (and some servers out there still only officially advertise draft support). TODO: Eventually only use \"h2\".",null,null],[11,"fmt","","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",58,{"inputs":[{"name":"vec"}],"output":{"name":"headerpart"}}],[11,"from","","",58,null],[11,"from","","",58,{"inputs":[{"name":"cow"}],"output":{"name":"headerpart"}}],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"from","","",58,null],[11,"eq","","",59,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"eq","","",60,{"inputs":[{"name":"self"},{"name":"ownedheader"}],"output":{"name":"bool"}}],[11,"clone","","",60,{"inputs":[{"name":"self"}],"output":{"name":"header"}}],[11,"eq","","",60,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"ne","","",60,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `Header` with the given name and value.",60,{"inputs":[{"name":"n"},{"name":"v"}],"output":{"name":"header"}}],[11,"name","","Return a borrowed representation of the `Header` name.",60,null],[11,"value","","Return a borrowed representation of the `Header` value.",60,null],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",60,{"inputs":[{"name":"self"}],"output":{"name":"ownedheader"}}],[11,"into","","",59,{"inputs":[{"name":"self"}],"output":{"name":"header"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"from","","Converts the given `u32` number to the appropriate `ErrorCode` variant.",2,{"inputs":[{"name":"u32"}],"output":{"name":"errorcode"}}],[11,"as_ref","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"into","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",61,{"inputs":[{"name":"self"},{"name":"connectionerror"}],"output":{"name":"bool"}}],[11,"ne","","",61,{"inputs":[{"name":"self"},{"name":"connectionerror"}],"output":{"name":"bool"}}],[11,"clone","","",61,{"inputs":[{"name":"self"}],"output":{"name":"connectionerror"}}],[11,"new","","Creates a new `ConnectionError` with no associated debug data.",61,{"inputs":[{"name":"errorcode"}],"output":{"name":"connectionerror"}}],[11,"with_debug_data","","Creates a new `ConnectionError` with the given associated debug data.",61,{"inputs":[{"name":"errorcode"},{"name":"vec"}],"output":{"name":"connectionerror"}}],[11,"error_code","","The error code of the underlying error.",61,{"inputs":[{"name":"self"}],"output":{"name":"errorcode"}}],[11,"debug_data","","The debug data attached to the connection error, if any.",61,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"debug_str","","The debug data interpreted as a string, if possible.",61,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",61,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"httperror"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"windowsize"}}],[11,"eq","","",62,{"inputs":[{"name":"self"},{"name":"windowsize"}],"output":{"name":"bool"}}],[11,"ne","","",62,{"inputs":[{"name":"self"},{"name":"windowsize"}],"output":{"name":"bool"}}],[11,"try_increase","","Tries to increase the window size by the given delta. If the WindowSize would overflow the maximum allowed value (2^31 - 1), returns an error case. If the increase succeeds, returns `Ok`.",62,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"try_decrease","","Tries to decrease the size of the window by the given delta.",62,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"new","","Creates a new `WindowSize` with the given initial size.",62,{"inputs":[{"name":"i32"}],"output":{"name":"windowsize"}}],[11,"size","","Returns the current size of the window.",62,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"httpscheme"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"httpscheme"}],"output":{"name":"bool"}}],[11,"as_bytes","","Returns a byte string representing the scheme.",4,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"response"}}],[11,"new","","Creates a new `Response` with all the components already provided.",0,{"inputs":[{"name":"streamid"},{"name":"vec"},{"name":"vec"}],"output":{"name":"response"}}],[11,"status_code","","Gets the response status code from the pseudo-header. If the response does not contain the response as the first pseuo-header, an error is returned as such a response is malformed.",0,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"request"}}],[0,"client","solicit","The module contains implementations of HTTP/2 clients that could be directly used to access HTTP/2 servers, i.e. send requests and read responses.",null,null],[3,"SimpleClient","solicit::client","A struct implementing a simple HTTP/2 client.",null,null],[3,"Client","","A struct representing an HTTP/2 client that receives responses to its requests asynchronously. Additionally, this client can be cloned and all clones can issue (concurrently) requests to the server, using the same underlying HTTP/2 connection.",null,null],[11,"with_stream","","Creates a new `SimpleClient` instance that will use the given `stream` instance for its underlying communication with the host. Additionally, requires the host identifier and the scheme of the connection.",63,{"inputs":[{"name":"s"},{"name":"string"},{"name":"httpscheme"}],"output":{"name":"httpresult"}}],[11,"with_connector","","A convenience constructor that first tries to establish an HTTP/2 connection by using the given connector instance (an implementation of the `HttpConnect` trait).",63,{"inputs":[{"name":"c"}],"output":{"name":"httpresult"}}],[11,"request","","Send a request to the server. Blocks until the entire request has been sent.",63,null],[11,"get_response","","Gets the response for the stream with the given ID. If a valid stream ID is given, it blocks until a response is received.",63,{"inputs":[{"name":"self"},{"name":"streamid"}],"output":{"name":"httpresult"}}],[11,"get","","Performs a GET request on the given path. This is a shortcut method for calling `request` followed by `get_response` for the returned stream ID.",63,null],[11,"post","","Performs a POST request on the given path.",63,null],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"client"}}],[11,"drop","","",64,{"inputs":[{"name":"self"}],"output":null}],[11,"with_connector","","Creates a brand new HTTP/2 client. This means that a new HTTP/2 connection will be established behind the scenes. A thread is spawned to handle the connection in the background, so that the thread that creates the client can use it asynchronously.",64,{"inputs":[{"name":"c"}],"output":{"name":"result"}}],[11,"request","","Issues a new request to the server.",64,null],[11,"get","","Issues a GET request to the server.",64,null],[11,"post","","Issues a POST request to the server.",64,null],[11,"ping","","Sends a PING to the server",64,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"server","solicit","The module contains a simple HTTP/2 server implementation.",null,null],[3,"ServerRequest","solicit::server","The struct represents a fully received request.",null,null],[12,"stream_id","","",65,null],[12,"headers","","",65,null],[12,"body","","",65,null],[3,"SimpleServer","","The struct implements a simple HTTP/2 server that allows users to register a request handler (a callback taking a `ServerRequest` and returning a `Response`) which is run on all received requests.",null,null],[11,"new","","Creates a new `SimpleServer` that will use the given `TransportStream` to communicate to the client. Assumes that the stream is fully uninitialized -- no preface sent or read yet.",66,{"inputs":[{"name":"ts"},{"name":"h"}],"output":{"name":"httpresult"}}],[11,"handle_next","","Handles the next incoming frame, blocking to receive it if nothing is available on the underlying stream.",66,{"inputs":[{"name":"self"}],"output":{"name":"httpresult"}}]],"paths":[[3,"Response"],[3,"Request"],[4,"ErrorCode"],[4,"HttpError"],[4,"HttpScheme"],[8,"FrameBuilder"],[3,"DataFrame"],[4,"DataFlag"],[3,"DataChunk"],[3,"StreamDependency"],[3,"HeadersFrame"],[4,"HeadersFlag"],[3,"RstStreamFrame"],[3,"SettingsFrame"],[4,"HttpSetting"],[4,"SettingsFlag"],[3,"GoawayFrame"],[3,"PingFlag"],[3,"PingFrame"],[3,"WindowUpdateFrame"],[8,"FrameIR"],[8,"Flag"],[8,"Frame"],[3,"NoFlag"],[3,"RawFrame"],[8,"TransportStream"],[3,"TransportReceiveFrame"],[3,"HttpConnection"],[3,"DataChunk"],[4,"HttpFrame"],[4,"SendStatus"],[4,"EndStream"],[8,"SendFrame"],[8,"ReceiveFrame"],[3,"HttpConnectionSender"],[3,"DefaultStream"],[4,"StreamState"],[4,"StreamDataError"],[4,"StreamDataChunk"],[8,"Session"],[8,"SessionState"],[8,"Stream"],[3,"StreamIter"],[3,"DefaultSessionState"],[8,"DataPrioritizer"],[3,"SimplePrioritizer"],[3,"ClientStream"],[3,"CleartextConnector"],[3,"RequestStream"],[3,"ClientConnection"],[3,"TlsConnector"],[4,"TlsConnectError"],[8,"HttpConnect"],[3,"CleartextConnectError"],[3,"ClientSession"],[3,"ServerConnection"],[8,"StreamFactory"],[3,"ServerSession"],[3,"HeaderPart"],[6,"OwnedHeader"],[3,"Header"],[3,"ConnectionError"],[3,"WindowSize"],[3,"SimpleClient"],[3,"Client"],[3,"ServerRequest"],[3,"SimpleServer"]]};
initSearch(searchIndex);
